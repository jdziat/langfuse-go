package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/jdziat/langfuse-go/internal/hooks/git"
)

const prepareCommitMsgHook = `#!/bin/bash
# langfuse-hooks: prepare-commit-msg
# Auto-generated by langfuse-hooks install

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2

# Skip if message already provided (-m flag) or amend/merge/squash
if [ -n "$COMMIT_SOURCE" ]; then
    exit 0
fi

# Check if langfuse-hooks is available
if ! command -v langfuse-hooks &> /dev/null; then
    exit 0
fi

# Check if disabled
if [ "$LANGFUSE_HOOKS_DISABLED" = "true" ]; then
    exit 0
fi

# Generate commit message
generated_msg=$(langfuse-hooks generate-commit 2>/dev/null)

if [ $? -eq 0 ] && [ -n "$generated_msg" ]; then
    echo "$generated_msg" > "$COMMIT_MSG_FILE"
fi
`

const commitMsgHook = `#!/bin/bash
# langfuse-hooks: commit-msg
# Auto-generated by langfuse-hooks install

COMMIT_MSG_FILE=$1
commit_msg=$(cat "$COMMIT_MSG_FILE")

# Check if langfuse-hooks is available
if ! command -v langfuse-hooks &> /dev/null; then
    exit 0
fi

# Check if disabled
if [ "$LANGFUSE_HOOKS_DISABLED" = "true" ]; then
    exit 0
fi

# Validate conventional commit format
if ! echo "$commit_msg" | head -1 | grep -qE "^(feat|fix|docs|test|refactor|perf|chore|ci|build|style)(\(.+\))?: .+"; then
    echo "Warning: Commit message doesn't follow conventional commits format"
    echo "Expected: type(scope): description"
    echo ""

    # Suggest a fix (non-interactive in hooks)
    suggested=$(langfuse-hooks fix-commit "$commit_msg" 2>/dev/null)
    if [ -n "$suggested" ]; then
        echo "Suggested message:"
        echo "$suggested"
        echo ""
        echo "Proceeding with original message. Use 'git commit --amend' to update."
    fi
fi

# Always allow the commit to proceed
exit 0
`

const postCheckoutHook = `#!/bin/bash
# langfuse-hooks: post-checkout
# Auto-generated by langfuse-hooks install

PREV_HEAD=$1
NEW_HEAD=$2
BRANCH_FLAG=$3

# Only trigger for branch creation (flag=1)
if [ "$BRANCH_FLAG" != "1" ]; then
    exit 0
fi

# Check if langfuse-hooks is available
if ! command -v langfuse-hooks &> /dev/null; then
    exit 0
fi

# Check if disabled
if [ "$LANGFUSE_HOOKS_DISABLED" = "true" ]; then
    exit 0
fi

current_branch=$(git branch --show-current)

# If branch name is generic, suggest a better name
if echo "$current_branch" | grep -qE "^(feature|fix|temp|test|wip|new|branch)$"; then
    echo ""
    echo "Generic branch name detected: $current_branch"
    echo "Tip: Use 'langfuse-hooks suggest-branch \"<description>\"' to generate a better name"
    echo "Then rename with: git branch -m <new-name>"
    echo ""
fi
`

// install installs the git hooks in the current repository.
func install() error {
	if !git.IsGitRepository() {
		return fmt.Errorf("not in a git repository")
	}

	hooksDir, err := git.GetHooksDir()
	if err != nil {
		return err
	}

	// Create hooks directory if it doesn't exist
	if err := os.MkdirAll(hooksDir, 0755); err != nil {
		return fmt.Errorf("failed to create hooks directory: %w", err)
	}

	hooks := map[string]string{
		"prepare-commit-msg": prepareCommitMsgHook,
		"commit-msg":         commitMsgHook,
		"post-checkout":      postCheckoutHook,
	}

	for name, content := range hooks {
		hookPath := filepath.Join(hooksDir, name)

		// Check if hook already exists
		if _, err := os.Stat(hookPath); err == nil {
			// Backup existing hook
			backupPath := hookPath + ".backup"
			if err := os.Rename(hookPath, backupPath); err != nil {
				return fmt.Errorf("failed to backup existing %s hook: %w", name, err)
			}
			fmt.Printf("Backed up existing %s hook to %s.backup\n", name, name)
		}

		// Write new hook
		if err := os.WriteFile(hookPath, []byte(content), 0755); err != nil {
			return fmt.Errorf("failed to write %s hook: %w", name, err)
		}

		fmt.Printf("Installed %s hook\n", name)
	}

	fmt.Println("\nHooks installed successfully!")
	fmt.Println("\nNext steps:")
	fmt.Println("1. Create .langfuse-hooks.yaml in your repository root (optional)")
	fmt.Println("2. Set your API key: export OPENAI_API_KEY=sk-...")
	fmt.Println("   Or for Anthropic: export ANTHROPIC_API_KEY=sk-ant-...")
	fmt.Println("3. Start committing!")

	return nil
}

// uninstall removes the git hooks from the current repository.
func uninstall() error {
	if !git.IsGitRepository() {
		return fmt.Errorf("not in a git repository")
	}

	hooksDir, err := git.GetHooksDir()
	if err != nil {
		return err
	}

	hooks := []string{"prepare-commit-msg", "commit-msg", "post-checkout"}

	for _, name := range hooks {
		hookPath := filepath.Join(hooksDir, name)

		// Check if hook exists and is ours
		content, err := os.ReadFile(hookPath)
		if err != nil {
			if os.IsNotExist(err) {
				continue
			}
			return fmt.Errorf("failed to read %s hook: %w", name, err)
		}

		// Only remove if it's our hook
		if !isOurHook(string(content)) {
			fmt.Printf("Skipping %s hook (not installed by langfuse-hooks)\n", name)
			continue
		}

		// Remove hook
		if err := os.Remove(hookPath); err != nil {
			return fmt.Errorf("failed to remove %s hook: %w", name, err)
		}

		// Restore backup if exists
		backupPath := hookPath + ".backup"
		if _, err := os.Stat(backupPath); err == nil {
			if err := os.Rename(backupPath, hookPath); err != nil {
				return fmt.Errorf("failed to restore %s hook backup: %w", name, err)
			}
			fmt.Printf("Restored %s hook from backup\n", name)
		} else {
			fmt.Printf("Removed %s hook\n", name)
		}
	}

	fmt.Println("\nHooks uninstalled successfully!")

	return nil
}

// isOurHook checks if a hook was installed by langfuse-hooks.
func isOurHook(content string) bool {
	return len(content) > 0 && (content[0:50] == "#!/bin/bash\n# langfuse-hooks:" ||
		(len(content) > 30 && content[12:30] == "langfuse-hooks:"))
}
